=begin

Highly divisible triangular number
Problem 12

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.
What is the value of the first triangle number to have over five hundred divisors?

=end

puts "-- Задача 10 + 2"

def num_of_primes num
    n = num
    i = 2
    p = 1

    return 1 if num == 1

    while n != 1
        a = 1
        while n % i == 0
            n /= i
            a += 1
        end
        i += 1
        p *= a
    end

    p
end

def solution x
    n = 1
    d = 1

    while (num_of_primes d) <= x
        n += 1
        d += n
    end
    return d
end

puts " Искомое треугольное число - #{solution 500}"

=begin

Pandigital products
Problem 32

    We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once; for example, the 5-digit number, 15234, is 1 through 5 pandigital.

    The product 7254 is unusual, as the identity, 39 × 186 = 7254, containing multiplicand, multiplier, and product is 1 through 9 pandigital.
    
    Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.
    
    HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum.

=end

puts "-- Задача 30 + 2"

def next_permitation permitation
    j = permitation.length - 2
    while permitation[j] > permitation[j + 1] && j > -1
        j -= 1
    end
    return -1 if j == -1
    l = permitation.length - 1
    while permitation[j] > permitation[l]
        l -= 1
    end
    permitation[j], permitation[l] = permitation[l], permitation[j]
    permitation = permitation[0..j] + permitation[j + 1..permitation.length - 1].reverse
end

array = [1, 2, 3, 4, 5, 6, 7, 8, 9]

until array == -1
    multiplicand = array[0]
    multiplier = array[1] * 1000 + array[2] * 100 + array[3] * 10 + array[4]
    product = array[5] * 1000 + array[6] * 100 + array[7] * 10 + array[8]
    if multiplicand * multiplier == product
        puts " #{multiplicand} x #{multiplier} = #{product}"
    end

    multiplicand = array[0] * 10 + array[1]
    multiplier = array[2] * 100 + array[3] * 10 + array[4]
    product = array[5] * 1000 + array[6] * 100 + array[7] * 10 + array[8]

    if multiplicand * multiplier == product
        puts " #{multiplicand} x #{multiplier} = #{product}"
    end
    array = next_permitation array
end